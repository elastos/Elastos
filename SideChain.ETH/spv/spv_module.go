package spv

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/elastos/Elastos.ELA.SideChain.ETH/event"
	"golang.org/x/net/context"
	"math/big"
	"path/filepath"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/elastos/Elastos.ELA.SPV/bloom"
	spv "github.com/elastos/Elastos.ELA.SPV/interface"
	"github.com/elastos/Elastos.ELA.SideChain.ETH"
	ethCommon "github.com/elastos/Elastos.ELA.SideChain.ETH/common"
	"github.com/elastos/Elastos.ELA.SideChain.ETH/core/events"
	"github.com/elastos/Elastos.ELA.SideChain.ETH/ethclient"
	"github.com/elastos/Elastos.ELA.SideChain.ETH/ethdb"
	"github.com/elastos/Elastos.ELA.SideChain.ETH/log"
	"github.com/elastos/Elastos.ELA.SideChain.ETH/node"
	"github.com/elastos/Elastos.ELA.SideChain/types"
	"github.com/elastos/Elastos.ELA/common"
	"github.com/elastos/Elastos.ELA/common/config"
	core "github.com/elastos/Elastos.ELA/core/types"
	"github.com/elastos/Elastos.ELA/core/types/payload"
)

var (
	dataDir          = "./"
	ipcClient        *ethclient.Client
	stack            *node.Node
	SpvService       *Service
	spvTxhash        string //Spv notification main chain hash
	spvTransactiondb *ethdb.LDBDatabase
	muiterator       sync.RWMutex
	muupti           sync.RWMutex
	candSend         int32     //1 can send recharge transactions, 0 can not send recharge transactions
	candIterator     int32 = 0 //0 Iteratively send recharge transactions, 1 can't iteratively send recharge transactions
	MinedBlockSub    *event.TypeMuxSubscription
	Signers          map[ethCommon.Address]struct{} // Set of authorized signers at this moment
)

const (
	databaseCache int = 768

	handles = 16

	//Unprocessed refill transaction index prefix
	UnTransaction string = "UnT-"

	// missingNumber is returned by GetBlockNumber if no header with the
	// given block hash has been stored in the database
	missingNumber = uint64(0xffffffffffffffff)

	//Cross-chain exchange rate
	rate int64 = 10000000000

	//Cross-chain recharge unprocessed transaction index
	UnTransactionIndex = "UnTI"

	//Cross-chain recharge unprocessed transaction seek
	UnTransactionSeek = "UnTS"

	// Fixed number of extra-data prefix bytes reserved for signer vanity
	extraVanity = 32

	// Fixed number of extra-data suffix bytes reserved for signer seal
	extraSeal = 65
)

//type MinedBlockEvent struct{}

type Config struct {
	// DataDir is the data path to store db files peer addresses etc.
	DataDir string

	// ActiveNet indicates the ELA network to connect with.
	ActiveNet string

	// GenesisAddress is the address generated by the side chain genesis block.
	GenesisAddress string
}

type Service struct {
	spv.SPVService
}

//Spv database initialization
func SpvDbInit(spvdataDir string) {
	db, err := ethdb.NewLDBDatabase(filepath.Join(spvdataDir, "spv_transaction_info.db"), databaseCache, handles)
	if err != nil {
		log.Error("spv Open db", "err", err)
		return
	}
	db.Meter("eth/db/ela/")
	spvTransactiondb = db
}

//Spv service initialization
func NewService(cfg *Config, s *node.Node) (*Service, error) {
	stack = s
	var chainParams *config.Params
	switch strings.ToLower(cfg.ActiveNet) {
	case "testnet", "test", "t":
		chainParams = config.DefaultParams.TestNet()
	case "regnet", "reg", "r":
		chainParams = config.DefaultParams.RegNet()
	default:
		chainParams = &config.DefaultParams

	}
	spvCfg := &spv.Config{
		DataDir:     cfg.DataDir,
		OnRollback:  nil, // Not implemented yet
	}
	//chainParams, spvCfg = ResetConfig(chainParams, spvCfg)
	ResetConfigWithReflect(chainParams, spvCfg)
	spvCfg.ChainParams = chainParams
	dataDir = cfg.DataDir
	initLog(cfg.DataDir)

	service, err := spv.NewSPVService(spvCfg)
	if err != nil {
		log.Error("Spv New DPOS SPVService: ", "err", err)
		return nil, err
	}

	SpvService = &Service{service}
	err = service.RegisterTransactionListener(&listener{
		address: cfg.GenesisAddress,
		service: service,
	})
	if err != nil {
		log.Error("Spv Register Transaction Listener: ", "err", err)
		return nil, err
	}
	client, err := stack.Attach()
	if err != nil {
		log.Error("Attach client: ", "err", err)
	}
	ipcClient = ethclient.NewClient(client)
	genesis, err := ipcClient.HeaderByNumber(context.Background(), new(big.Int).SetInt64(0))
	if err != nil {
		log.Error("IpcClient: ", "err", err)
	}
	singersNum := (len(genesis.Extra) - extraVanity - extraSeal) / ethCommon.AddressLength
	if singersNum > 0 {
		signers := make([]ethCommon.Address, singersNum)
		for i := 0; i < singersNum; i++ {
			copy(signers[i][:], genesis.Extra[extraVanity+i*ethCommon.AddressLength:])
		}
		Signers = make(map[ethCommon.Address]struct{})
		for _, signer := range signers {
			Signers[signer] = struct{}{}
		}
	}
	MinedBlockSub = s.EventMux().Subscribe(events.MinedBlockEvent{})
	go minedBroadcastLoop(MinedBlockSub)
	return SpvService, nil
}

//minedBroadcastLoop Mining awareness, eth can initiate a recharge transaction after the block
func minedBroadcastLoop(minedBlockSub *event.TypeMuxSubscription) {
	var i = 0

	for {
		select {
		case <-minedBlockSub.Chan():
			i++
			if i >= 2 {
				atomic.StoreInt32(&candSend, 1)
				from, ok := getDefaultSingerAddr()
				if ok {
					IteratorUnTransaction(from)
				}
			}

		case <-time.After(3 * time.Minute):
			i = 0
			atomic.StoreInt32(&candSend, 0)

		}
	}

}

func (s *Service) GetDatabase() *ethdb.LDBDatabase {
	return spvTransactiondb
}

func (s *Service) VerifyTransaction(tx *types.Transaction) error {
	payload, ok := tx.Payload.(*types.PayloadRechargeToSideChain)
	if !ok {
		return errors.New("[VerifyTransaction] Invalid payload core.PayloadRechargeToSideChain")
	}

	switch tx.PayloadVersion {
	case types.RechargeToSideChainPayloadVersion0:

		proof := new(bloom.MerkleProof)
		mainChainTransaction := new(core.Transaction)

		reader := bytes.NewReader(payload.MerkleProof)
		if err := proof.Deserialize(reader); err != nil {
			return errors.New("[VerifyTransaction] RechargeToSideChain payload deserialize failed")
		}

		reader = bytes.NewReader(payload.MainChainTransaction)
		if err := mainChainTransaction.Deserialize(reader); err != nil {
			return errors.New("[VerifyTransaction] RechargeToSideChain mainChainTransaction deserialize failed")
		}

		if err := s.SPVService.VerifyTransaction(*proof, *mainChainTransaction); err != nil {
			return errors.New("[VerifyTransaction] SPV module verify transaction failed.")
		}

	case types.RechargeToSideChainPayloadVersion1:

		_, err := s.GetTransaction(&payload.MainChainTransactionHash)
		if err != nil {
			return errors.New("[VerifyTransaction] Main chain transaction not found")
		}

	default:
		return errors.New("[VerifyTransaction] invalid payload version.")
	}

	return nil
}

func (s *Service) VerifyElaHeader(hash *common.Uint256) error {
	blockChain := s.HeaderStore()
	_, err := blockChain.Get(hash)
	if err != nil {
		return errors.New("[VerifyElaHeader] Verify ela header failed.")
	}
	return nil
}

type listener struct {
	address string
	service spv.SPVService
}

func (l *listener) Address() string {
	return l.address
}

func (l *listener) Type() core.TxType {
	return core.TransferCrossChainAsset
}

func (l *listener) Flags() uint64 {
	return spv.FlagNotifyInSyncing | spv.FlagNotifyConfirmed
}

func (l *listener) Notify(id common.Uint256, proof bloom.MerkleProof, tx core.Transaction) {
	// Submit transaction receipt
	log.Info("========================================================================================")
	log.Info("mainchain transaction info")
	log.Info("----------------------------------------------------------------------------------------")
	log.Info(string(tx.String()))
	log.Info("----------------------------------------------------------------------------------------")
	savePayloadInfo(tx)
	l.service.SubmitTransactionReceipt(id, tx.Hash())
}

// get default singer address
func getDefaultSingerAddr() (ethCommon.Address, bool) {
	var addr ethCommon.Address
	if wallets := stack.AccountManager().Wallets(); len(wallets) > 0 {
		if accounts := wallets[0].Accounts(); len(accounts) > 0 {
			addr = accounts[0].Address
		}
	}
	_, ok := Signers[addr]
	return addr, ok
}

//savePayloadInfo save and send spv perception
func savePayloadInfo(elaTx core.Transaction) {
	nr := bytes.NewReader(elaTx.Payload.Data(elaTx.PayloadVersion))
	p := new(payload.TransferCrossChainAsset)
	p.Deserialize(nr, elaTx.PayloadVersion)
	var fees []string
	var address []string
	var outputs []string
	for i, amount := range p.CrossChainAmounts {
		fees = append(fees, (elaTx.Outputs[i].Value - amount).String())
		outputs = append(outputs, elaTx.Outputs[i].Value.String())
		address = append(address, p.CrossChainAddresses[i])
	}
	addr := strings.Join(address, ",")
	fee := strings.Join(fees, ",")
	output := strings.Join(outputs, ",")
	if spvTxhash == elaTx.Hash().String() {
		return
	}
	spvTxhash = elaTx.Hash().String()
	err := spvTransactiondb.Put([]byte(elaTx.Hash().String()+"Fee"), []byte(fee))

	if err != nil {
		log.Error("SpvServicedb Put Fee: ", "err", err, "elaHash", elaTx.Hash().String())
	}

	err = spvTransactiondb.Put([]byte(elaTx.Hash().String()+"Address"), []byte(addr))

	if err != nil {
		log.Error("SpvServicedb Put Address: ", "err", err, "elaHash", elaTx.Hash().String())
	}
	err = spvTransactiondb.Put([]byte(elaTx.Hash().String()+"Output"), []byte(output))

	if err != nil {
		log.Error("SpvServicedb Put Output: ", "err", err, "elaHash", elaTx.Hash().String())
	}
	if atomic.LoadInt32(&candSend) == 1 {
		from, ok := getDefaultSingerAddr()
		if ok {
			IteratorUnTransaction(from)
			f, err := common.StringToFixed64(fees[0])
			if err != nil {
				log.Error("SpvSendTransaction Fee StringToFixed64: ", "err", err, "elaHash", elaTx)
				return

			}
			fe := new(big.Int).SetInt64(f.IntValue())
			y := new(big.Int).SetInt64(rate)
			fee := new(big.Int).Mul(fe, y)
			SendTransaction(from, elaTx.Hash().String(), fee)
		}
	} else {
		UpTransactionIndex(elaTx.Hash().String())
	}
	return
}

//UpTransactionIndex records spv-aware refill transaction index
func UpTransactionIndex(elaTx string) {
	muupti.Lock()
	defer muupti.Unlock()
	if strings.HasPrefix(elaTx, "0x") {
		elaTx = elaTx[2:]
	}
	index := GetUnTransactionNum(spvTransactiondb, UnTransactionIndex)
	if index == missingNumber {
		index = 1
	}
	err := spvTransactiondb.Put(append([]byte(UnTransaction), encodeUnTransactionNumber(index)...), []byte(elaTx))
	if err != nil {
		log.Error(fmt.Sprintf("SpvServicedb Put UnTransaction: %v", err), "elaHash", elaTx)
	}
	log.Info(UnTransaction+"put", "index", index, "elaTx", elaTx)
	err = spvTransactiondb.Put([]byte(UnTransactionIndex), encodeUnTransactionNumber(index+1))
	if err != nil {
		log.Error("UnTransactionIndexPut", err, index+1)
		return
	}
	log.Info(UnTransactionIndex+"put", "index", index+1)

}

//IteratorUnTransaction iterates before mining and processes existing spv refill transactions
func IteratorUnTransaction(from ethCommon.Address) {
	muiterator.Lock()
	defer muiterator.Unlock()
	if atomic.LoadInt32(&candIterator) == 1 {
		return
	}
	atomic.StoreInt32(&candIterator, 1)
	go func(addr ethCommon.Address) {
		for {
			// stop send tx if candSend == 0
			if atomic.LoadInt32(&candSend) == 0 {
				break
			}
			index := GetUnTransactionNum(spvTransactiondb, UnTransactionIndex)
			if index == missingNumber {
				break
			}
			seek := GetUnTransactionNum(spvTransactiondb, UnTransactionSeek)
			if seek == missingNumber {
				seek = 1
			}
			if seek == index {
				break
			}
			txHash, err := spvTransactiondb.Get(append([]byte(UnTransaction), encodeUnTransactionNumber(seek)...))
			if err != nil {
				log.Error("get UnTransaction ", "err", err, "seek", seek)
				break
			}
			fee, _, _ := FindOutputFeeAndaddressByTxHash(string(txHash))
			if fee.Uint64() <= 0 {
				break
			}
			SendTransaction(from, string(txHash), fee)
			err = spvTransactiondb.Put([]byte(UnTransactionSeek), encodeUnTransactionNumber(seek+1))
			log.Info(UnTransactionSeek+"put", "seek", seek+1)
			if err != nil {
				log.Error("UnTransactionIndexPutSeek ", err, seek+1)
				break
			}
			err = spvTransactiondb.Delete(append([]byte(UnTransaction), encodeUnTransactionNumber(seek)...))
			log.Info(UnTransaction+"delete", "seek", seek)
			if err != nil {
				log.Error("UnTransactionIndexDeleteSeek ", "err", err, "seek", seek)
				break
			}
		}
		atomic.StoreInt32(&candIterator, 0)
	}(from)
}

//SendTransaction sends a reload transaction to txpool
func SendTransaction(from ethCommon.Address, elaTx string, fee *big.Int) {
	ethTx, err := ipcClient.StorageAt(context.Background(), ethCommon.Address{}, ethCommon.HexToHash("0x"+elaTx), nil)
	if err != nil {
		log.Error(fmt.Sprintf("IpcClient StorageAt: %v", err))
		return
	}
	h := ethCommon.Hash{}
	if ethCommon.BytesToHash(ethTx) != h {
		log.Warn("Cross-chain transactions have been processed", "elaHash", elaTx)
		return
	}
	data, err := common.HexStringToBytes(elaTx)
	if err != nil {
		log.Error("elaTx HexStringToBytes: "+elaTx, "err", err)
		return
	}
	msg := ethereum.CallMsg{From: from, To: &ethCommon.Address{}, Data: data}
	gasLimit, err := ipcClient.EstimateGas(context.Background(), msg)
	if err != nil {
		log.Error("IpcClient EstimateGas:", "err", err, "main txhash", elaTx)
		return
	}
	if gasLimit == 0 {
		return
	}

	price := new(big.Int).Quo(fee, new(big.Int).SetUint64(gasLimit))
	callmsg := ethereum.TXMsg{From: from, To: &ethCommon.Address{}, Gas: gasLimit, Data: data, GasPrice: price}
	hash, err := ipcClient.SendPublicTransaction(context.Background(), callmsg)
	if err != nil {
		log.Error("IpcClient SendPublicTransaction: ", "err", err)
		return
	}
	log.Info("Cross chain Transaction", "elaTx", elaTx, "ethTh", hash.String())
}

func encodeUnTransactionNumber(number uint64) []byte {
	enc := make([]byte, 8)
	binary.BigEndian.PutUint64(enc, number)
	return enc
}

func GetUnTransactionNum(db DatabaseReader, Prefix string) uint64 {
	data, _ := db.Get([]byte(Prefix))
	if len(data) != 8 {
		return missingNumber
	}
	return binary.BigEndian.Uint64(data)
}

// DatabaseReader wraps the Get method of a backing data store.
type DatabaseReader interface {
	Get(key []byte) (value []byte, err error)
}

//FindOutputFeeAndaddressByTxHash Finds the eth recharge address, recharge amount, and transaction fee based on the main chain hash.
func FindOutputFeeAndaddressByTxHash(transactionHash string) (*big.Int, ethCommon.Address, *big.Int) {
	var emptyaddr ethCommon.Address
	transactionHash = strings.Replace(transactionHash, "0x", "", 1)
	if spvTransactiondb == nil {
		return new(big.Int), emptyaddr, new(big.Int)
	}
	v, err := spvTransactiondb.Get([]byte(transactionHash + "Fee"))
	if err != nil {
		log.Error("SpvServicedb Get Fee: ", "err", err, "elaHash", transactionHash)
		return new(big.Int), emptyaddr, new(big.Int)
	}
	fees := strings.Split(string(v), ",")
	f, err := common.StringToFixed64(fees[0])
	if err != nil {
		log.Error("SpvServicedb Get Fee StringToFixed64: ", "err", err, "elaHash", transactionHash)
		return new(big.Int), emptyaddr, new(big.Int)

	}
	fe := new(big.Int).SetInt64(f.IntValue())
	y := new(big.Int).SetInt64(rate)

	addrss, err := spvTransactiondb.Get([]byte(transactionHash + "Address"))
	if err != nil {
		log.Error("SpvServicedb Get Address: ", "err", err, "elaHash", transactionHash)
		return new(big.Int), emptyaddr, new(big.Int)

	}
	addrs := strings.Split(string(addrss), ",")
	if !ethCommon.IsHexAddress(addrs[0]) {
		return new(big.Int), emptyaddr, new(big.Int)
	}
	outputs, err := spvTransactiondb.Get([]byte(transactionHash + "Output"))
	if err != nil {
		log.Error("SpvServicedb Get elaHash: ", "err", err, "elaHash", transactionHash)
		return new(big.Int), emptyaddr, new(big.Int)

	}
	output := strings.Split(string(outputs), ",")
	o, err := common.StringToFixed64(output[0])
	if err != nil {
		log.Error("SpvServicedb Get elaHash StringToFixed64: ", "err", err, "elaHash", transactionHash)
		return new(big.Int), emptyaddr, new(big.Int)

	}
	op := new(big.Int).SetInt64(o.IntValue())
	return new(big.Int).Mul(fe, y), ethCommon.HexToAddress(addrs[0]), new(big.Int).Mul(op, y)
}
