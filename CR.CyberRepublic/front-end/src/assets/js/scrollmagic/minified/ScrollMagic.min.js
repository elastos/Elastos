/*! ScrollMagic v2.0.5 | (c) 2015 Jan Paepke (@janpaepke) | license & info: http://scrollmagic.io */
!(function(e, t) {typeof define === 'function' && define.amd ? define(t) : typeof exports === 'object' ? module.exports = t() : e.ScrollMagic = t()}(this, () => { const e = function() {}; e.version = '2.0.5', window.addEventListener('mousewheel', () => {}); const t = 'data-scrollmagic-pin-spacer'; e.Controller = function(r) {var o, s, a = 'ScrollMagic.Controller', l = 'FORWARD', c = 'REVERSE', u = 'PAUSED', f = n.defaults, d = this, h = i.extend({}, f, r), g = [], p = !1, v = 0, m = u, w = !0, y = 0, S = !0, b = function() {for (const e in h)f.hasOwnProperty(e) || delete h[e]; if (h.container = i.get.elements(h.container)[0], !h.container) throw `${a} init failed.`; w = h.container === window || h.container === document.body || !document.body.contains(h.container), w && (h.container = window), y = z(), h.container.addEventListener('resize', T), h.container.addEventListener('scroll', T), h.refreshInterval = parseInt(h.refreshInterval) || f.refreshInterval, E()}, E = function() {h.refreshInterval > 0 && (s = window.setTimeout(A, h.refreshInterval))}, x = function() {return h.vertical ? i.get.scrollTop(h.container) : i.get.scrollLeft(h.container)}, z = function() {return h.vertical ? i.get.height(h.container) : i.get.width(h.container)}, C = this._setScrollPos = function(e) {h.vertical ? w ? window.scrollTo(i.get.scrollLeft(), e) : h.container.scrollTop = e : w ? window.scrollTo(e, i.get.scrollTop()) : h.container.scrollLeft = e}, F = function() {if (S && p) {const e = i.type.Array(p) ? p : g.slice(0); p = !1; const t = v; v = d.scrollPos(); const n = v - t; n !== 0 && (m = n > 0 ? l : c), m === c && e.reverse(), e.forEach((e) => {e.update(!0)})}}, L = function() {o = i.rAF(F)}, T = function(e) {e.type == 'resize' && (y = z(), m = u), p !== !0 && (p = !0, L())}, A = function() {if (!w && y != z()) {let e; try {e = new Event('resize', {bubbles: !1, cancelable: !1})} catch (t) {e = document.createEvent('Event'), e.initEvent('resize', !1, !1)}h.container.dispatchEvent(e)}g.forEach((e) => {e.refresh()}), E()}; this._options = h; const O = function(e) {if (e.length <= 1) return e; const t = e.slice(0); return t.sort((e, t) => {return e.scrollOffset() > t.scrollOffset() ? 1 : -1}), t}; return this.addScene = function(t) {if (i.type.Array(t))t.forEach((e) => {d.addScene(e)}); else if (t instanceof e.Scene) if (t.controller() !== d)t.addTo(d); else if (g.indexOf(t) < 0) {g.push(t), g = O(g), t.on('shift.controller_sort', () => {g = O(g)}); for (const n in h.globalSceneOptions)t[n] && t[n].call(t, h.globalSceneOptions[n])} return d}, this.removeScene = function(e) {if (i.type.Array(e))e.forEach((e) => {d.removeScene(e)}); else {const t = g.indexOf(e); t > -1 && (e.off('shift.controller_sort'), g.splice(t, 1), e.remove())} return d}, this.updateScene = function(t, n) {return i.type.Array(t) ? t.forEach((e) => {d.updateScene(e, n)}) : n ? t.update(!0) : p !== !0 && t instanceof e.Scene && (p = p || [], p.indexOf(t) == -1 && p.push(t), p = O(p), L()), d}, this.update = function(e) {return T({type: 'resize'}), e && F(), d}, this.scrollTo = function(n, r) {if (i.type.Number(n))C.call(h.container, n, r); else if (n instanceof e.Scene)n.controller() === d && d.scrollTo(n.scrollOffset(), r); else if (i.type.Function(n))C = n; else {let o = i.get.elements(n)[0]; if (o) {for (;o.parentNode.hasAttribute(t);)o = o.parentNode; let s = h.vertical ? 'top' : 'left', a = i.get.offset(h.container), l = i.get.offset(o); w || (a[s] -= d.scrollPos()), d.scrollTo(l[s] - a[s], r)}} return d}, this.scrollPos = function(e) {return arguments.length ? (i.type.Function(e) && (x = e), d) : x.call(d)}, this.info = function(e) {const t = {size: y, vertical: h.vertical, scrollPos: v, scrollDirection: m, container: h.container, isDocument: w}; return arguments.length ? void 0 !== t[e] ? t[e] : void 0 : t}, this.loglevel = function() {return d}, this.enabled = function(e) {return arguments.length ? (S != e && (S = !!e, d.updateScene(g, !0)), d) : S}, this.destroy = function(e) {window.clearTimeout(s); for (let t = g.length; t--;)g[t].destroy(e); return h.container.removeEventListener('resize', T), h.container.removeEventListener('scroll', T), i.cAF(o), null}, b(), d}; var n = {defaults: {container: window, vertical: !0, globalSceneOptions: {}, loglevel: 2, refreshInterval: 100}}; e.Controller.addOption = function(e, t) {n.defaults[e] = t}, e.Controller.extend = function(t) {const n = this; e.Controller = function() {return n.apply(this, arguments), this.$super = i.extend({}, this), t.apply(this, arguments) || this}, i.extend(e.Controller, n), e.Controller.prototype = n.prototype, e.Controller.prototype.constructor = e.Controller}, e.Scene = function(n) {let o, s, a = 'BEFORE', l = 'DURING', c = 'AFTER', u = r.defaults, f = this, d = i.extend({}, u, n), h = a, g = 0, p = {start: 0, end: 0}, v = 0, m = !0, w = function() {for (const e in d)u.hasOwnProperty(e) || delete d[e]; for (const t in u)L(t); C()}, y = {}; this.on = function(e, t) {return i.type.Function(t) && (e = e.trim().split(' '), e.forEach((e) => {let n = e.split('.'), r = n[0], i = n[1]; r != '*' && (y[r] || (y[r] = []), y[r].push({namespace: i || '', callback: t}))})), f}, this.off = function(e, t) {return e ? (e = e.trim().split(' '), e.forEach((e) => {let n = e.split('.'), r = n[0], i = n[1] || '', o = r === '*' ? Object.keys(y) : [r]; o.forEach((e) => {for (var n = y[e] || [], r = n.length; r--;) {const o = n[r]; !o || i !== o.namespace && i !== '*' || t && t != o.callback || n.splice(r, 1)}n.length || delete y[e]})}), f) : f}, this.trigger = function(t, n) {if (t) {let r = t.trim().split('.'), i = r[0], o = r[1], s = y[i]; s && s.forEach((t) => {o && o !== t.namespace || t.callback.call(f, new e.Event(i, t.namespace, f, n))})} return f}, f.on('change.internal', (e) => {e.what !== 'loglevel' && e.what !== 'tweenChanges' && (e.what === 'triggerElement' ? E() : e.what === 'reverse' && f.update())}).on('shift.internal', () => {S(), f.update()}), this.addTo = function(t) {return t instanceof e.Controller && s != t && (s && s.removeScene(f), s = t, C(), b(!0), E(!0), S(), s.info('container').addEventListener('resize', x), t.addScene(f), f.trigger('add', {controller: s}), f.update()), f}, this.enabled = function(e) {return arguments.length ? (m != e && (m = !!e, f.update(!0)), f) : m}, this.remove = function() {if (s) {s.info('container').removeEventListener('resize', x); const e = s; s = void 0, e.removeScene(f), f.trigger('remove')} return f}, this.destroy = function(e) {return f.trigger('destroy', {reset: e}), f.remove(), f.off('*.*'), null}, this.update = function(e) {if (s) if (e) if (s.enabled() && m) {let t, n = s.info('scrollPos'); t = d.duration > 0 ? (n - p.start) / (p.end - p.start) : n >= p.start ? 1 : 0, f.trigger('update', {startPos: p.start, endPos: p.end, scrollPos: n}), f.progress(t)} else T && h === l && O(!0); else s.updateScene(f, !1); return f}, this.refresh = function() {return b(), E(), f}, this.progress = function(e) {if (arguments.length) {let t = !1, n = h, r = s ? s.info('scrollDirection') : 'PAUSED', i = d.reverse || e >= g; if (d.duration === 0 ? (t = g != e, g = e < 1 && i ? 0 : 1, h = g === 0 ? a : l) : e < 0 && h !== a && i ? (g = 0, h = a, t = !0) : e >= 0 && e < 1 && i ? (g = e, h = l, t = !0) : e >= 1 && h !== c ? (g = 1, h = c, t = !0) : h !== l || i || O(), t) {let o = {progress: g, state: h, scrollDirection: r}, u = h != n, p = function(e) {f.trigger(e, o)}; u && n !== l && (p('enter'), p(n === a ? 'start' : 'end')), p('progress'), u && h !== l && (p(h === a ? 'start' : 'end'), p('leave'))} return f} return g}; var S = function() {p = {start: v + d.offset}, s && d.triggerElement && (p.start -= s.info('size') * d.triggerHook), p.end = p.start + d.duration}, b = function(e) {if (o) {const t = 'duration'; F(t, o.call(f)) && !e && (f.trigger('change', {what: t, newval: d[t]}), f.trigger('shift', {reason: t}))}}, E = function(e) {let n = 0, r = d.triggerElement; if (s && r) {for (var o = s.info(), a = i.get.offset(o.container), l = o.vertical ? 'top' : 'left'; r.parentNode.hasAttribute(t);)r = r.parentNode; const c = i.get.offset(r); o.isDocument || (a[l] -= s.scrollPos()), n = c[l] - a[l]} const u = n != v; v = n, u && !e && f.trigger('shift', {reason: 'triggerElementPosition'})}, x = function() {d.triggerHook > 0 && f.trigger('shift', {reason: 'containerResize'})}, z = i.extend(r.validate, {duration(e) {if (i.type.String(e) && e.match(/^(\.|\d)*\d+%$/)) {const t = parseFloat(e) / 100; e = function() {return s ? s.info('size') * t : 0}} if (i.type.Function(e)) {o = e; try {e = parseFloat(o())} catch (n) {e = -1}} if (e = parseFloat(e), !i.type.Number(e) || e < 0) throw o ? (o = void 0, 0) : 0; return e}}), C = function(e) {e = arguments.length ? [e] : Object.keys(z), e.forEach((e) => {let t; if (z[e]) try {t = z[e](d[e])} catch (n) {t = u[e]} finally {d[e] = t}})}, F = function(e, t) {let n = !1, r = d[e]; return d[e] != t && (d[e] = t, C(e), n = r != d[e]), n}, L = function(e) {f[e] || (f[e] = function(t) {return arguments.length ? (e === 'duration' && (o = void 0), F(e, t) && (f.trigger('change', {what: e, newval: d[e]}), r.shifts.indexOf(e) > -1 && f.trigger('shift', {reason: e})), f) : d[e]})}; this.controller = function() {return s}, this.state = function() {return h}, this.scrollOffset = function() {return p.start}, this.triggerPosition = function() {let e = d.offset; return s && (e += d.triggerElement ? v : s.info('size') * f.triggerHook()), e}; let T, A; f.on('shift.internal', (e) => {const t = e.reason === 'duration'; (h === c && t || h === l && d.duration === 0) && O(), t && _()}).on('progress.internal', () => {O()}).on('add.internal', () => {_()}).on('destroy.internal', (e) => {f.removePin(e.reset)}); var O = function(e) {if (T && s) {let t = s.info(), n = A.spacer.firstChild; if (e || h !== l) {let r = {position: A.inFlow ? 'relative' : 'absolute', top: 0, left: 0}, o = i.css(n, 'position') != r.position; A.pushFollowers ? d.duration > 0 && (h === c && parseFloat(i.css(A.spacer, 'padding-top')) === 0 ? o = !0 : h === a && parseFloat(i.css(A.spacer, 'padding-bottom')) === 0 && (o = !0)) : r[t.vertical ? 'top' : 'left'] = d.duration * g, i.css(n, r), o && _()} else {i.css(n, 'position') != 'fixed' && (i.css(n, {position: 'fixed'}), _()); let u = i.get.offset(A.spacer, !0), f = d.reverse || d.duration === 0 ? t.scrollPos - p.start : Math.round(g * d.duration * 10) / 10; u[t.vertical ? 'top' : 'left'] += f, i.css(A.spacer.firstChild, {top: u.top, left: u.left})}}}, _ = function() {if (T && s && A.inFlow) {let e = h === l, t = s.info('vertical'), n = A.spacer.firstChild, r = i.isMarginCollapseType(i.css(A.spacer, 'display')), o = {}; A.relSize.width || A.relSize.autoFullWidth ? e ? i.css(T, {width: i.get.width(A.spacer)}) : i.css(T, {width: '100%'}) : (o['min-width'] = i.get.width(t ? T : n, !0, !0), o.width = e ? o['min-width'] : 'auto'), A.relSize.height ? e ? i.css(T, {height: i.get.height(A.spacer) - (A.pushFollowers ? d.duration : 0)}) : i.css(T, {height: '100%'}) : (o['min-height'] = i.get.height(t ? n : T, !0, !r), o.height = e ? o['min-height'] : 'auto'), A.pushFollowers && (o[`padding${t ? 'Top' : 'Left'}`] = d.duration * g, o[`padding${t ? 'Bottom' : 'Right'}`] = d.duration * (1 - g)), i.css(A.spacer, o)}}, N = function() {s && T && h === l && !s.info('isDocument') && O()}, P = function() {s && T && h === l && ((A.relSize.width || A.relSize.autoFullWidth) && i.get.width(window) != i.get.width(A.spacer.parentNode) || A.relSize.height && i.get.height(window) != i.get.height(A.spacer.parentNode)) && _()}, D = function(e) {s && T && h === l && !s.info('isDocument') && (e.preventDefault(), s._setScrollPos(s.info('scrollPos') - ((e.wheelDelta || e[s.info('vertical') ? 'wheelDeltaY' : 'wheelDeltaX']) / 3 || 30 * -e.detail)))}; this.setPin = function(e, n) {const r = {pushFollowers: !0, spacerClass: 'scrollmagic-pin-spacer'}; if (n = i.extend({}, r, n), e = i.get.elements(e)[0], !e) return f; if (i.css(e, 'position') === 'fixed') return f; if (T) {if (T === e) return f; f.removePin()}T = e; let o = T.parentNode.style.display, s = ['top', 'left', 'bottom', 'right', 'margin', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom']; T.parentNode.style.display = 'none'; let a = i.css(T, 'position') != 'absolute', l = i.css(T, s.concat(['display'])), c = i.css(T, ['width', 'height']); T.parentNode.style.display = o, !a && n.pushFollowers && (n.pushFollowers = !1); let u = T.parentNode.insertBefore(document.createElement('div'), T), d = i.extend(l, {position: a ? 'relative' : 'absolute', boxSizing: 'content-box', mozBoxSizing: 'content-box', webkitBoxSizing: 'content-box'}); if (a || i.extend(d, i.css(T, ['width', 'height'])), i.css(u, d), u.setAttribute(t, ''), i.addClass(u, n.spacerClass), A = {spacer: u, relSize: {width: c.width.slice(-1) === '%', height: c.height.slice(-1) === '%', autoFullWidth: c.width === 'auto' && a && i.isMarginCollapseType(l.display)}, pushFollowers: n.pushFollowers, inFlow: a}, !T.___origStyle) {T.___origStyle = {}; let h = T.style, g = s.concat(['width', 'height', 'position', 'boxSizing', 'mozBoxSizing', 'webkitBoxSizing']); g.forEach((e) => {T.___origStyle[e] = h[e] || ''})} return A.relSize.width && i.css(u, {width: c.width}), A.relSize.height && i.css(u, {height: c.height}), u.appendChild(T), i.css(T, {position: a ? 'relative' : 'absolute', margin: 'auto', top: 'auto', left: 'auto', bottom: 'auto', right: 'auto'}), (A.relSize.width || A.relSize.autoFullWidth) && i.css(T, {boxSizing: 'border-box', mozBoxSizing: 'border-box', webkitBoxSizing: 'border-box'}), window.addEventListener('scroll', N), window.addEventListener('resize', N), window.addEventListener('resize', P), T.addEventListener('mousewheel', D), T.addEventListener('DOMMouseScroll', D), O(), f}, this.removePin = function(e) {if (T) {if (h === l && O(!0), e || !s) {const n = A.spacer.firstChild; if (n.hasAttribute(t)) {let r = A.spacer.style, o = ['margin', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom']; margins = {}, o.forEach((e) => {margins[e] = r[e] || ''}), i.css(n, margins)}A.spacer.parentNode.insertBefore(n, A.spacer), A.spacer.parentNode.removeChild(A.spacer), T.parentNode.hasAttribute(t) || (i.css(T, T.___origStyle), delete T.___origStyle)}window.removeEventListener('scroll', N), window.removeEventListener('resize', N), window.removeEventListener('resize', P), T.removeEventListener('mousewheel', D), T.removeEventListener('DOMMouseScroll', D), T = void 0} return f}; let R, k = []; return f.on('destroy.internal', (e) => {f.removeClassToggle(e.reset)}), this.setClassToggle = function(e, t) {const n = i.get.elements(e); return n.length !== 0 && i.type.String(t) ? (k.length > 0 && f.removeClassToggle(), R = t, k = n, f.on('enter.internal_class leave.internal_class', (e) => {const t = e.type === 'enter' ? i.addClass : i.removeClass; k.forEach((e) => {t(e, R)})}), f) : f}, this.removeClassToggle = function(e) {return e && k.forEach((e) => {i.removeClass(e, R)}), f.off('start.internal_class end.internal_class'), R = void 0, k = [], f}, w(), f}; var r = {defaults: {duration: 0, offset: 0, triggerElement: void 0, triggerHook: 0.5, reverse: !0, loglevel: 2}, validate: {offset(e) {if (e = parseFloat(e), !i.type.Number(e)) throw 0; return e}, triggerElement(e) {if (e = e || void 0) {const t = i.get.elements(e)[0]; if (!t) throw 0; e = t} return e}, triggerHook(e) {const t = {onCenter: 0.5, onEnter: 1, onLeave: 0}; if (i.type.Number(e))e = Math.max(0, Math.min(parseFloat(e), 1)); else {if (!(e in t)) throw 0; e = t[e]} return e}, reverse(e) {return !!e}}, shifts: ['duration', 'offset', 'triggerHook']}; e.Scene.addOption = function(e, t, n, i) {e in r.defaults || (r.defaults[e] = t, r.validate[e] = n, i && r.shifts.push(e))}, e.Scene.extend = function(t) {const n = this; e.Scene = function() {return n.apply(this, arguments), this.$super = i.extend({}, this), t.apply(this, arguments) || this}, i.extend(e.Scene, n), e.Scene.prototype = n.prototype, e.Scene.prototype.constructor = e.Scene}, e.Event = function(e, t, n, r) {r = r || {}; for (const i in r) this[i] = r[i]; return this.type = e, this.target = this.currentTarget = n, this.namespace = t || '', this.timeStamp = this.timestamp = Date.now(), this}; var i = e._util = (function(e) {let t, n = {}, r = function(e) {return parseFloat(e) || 0}, i = function(t) {return t.currentStyle ? t.currentStyle : e.getComputedStyle(t)}, o = function(t, n, o, s) {if (n = n === document ? e : n, n === e)s = !1; else if (!f.DomElement(n)) return 0; t = t.charAt(0).toUpperCase() + t.substr(1).toLowerCase(); let a = (o ? n[`offset${t}`] || n[`outer${t}`] : n[`client${t}`] || n[`inner${t}`]) || 0; if (o && s) {const l = i(n); a += t === 'Height' ? r(l.marginTop) + r(l.marginBottom) : r(l.marginLeft) + r(l.marginRight)} return a}, s = function(e) {return e.replace(/^[^a-z]+([a-z])/g, '$1').replace(/-([a-z])/g, (e) => {return e[1].toUpperCase()})}; n.extend = function(e) {for (e = e || {}, t = 1; t < arguments.length; t++) if (arguments[t]) for (const n in arguments[t])arguments[t].hasOwnProperty(n) && (e[n] = arguments[t][n]); return e}, n.isMarginCollapseType = function(e) {return ['block', 'flex', 'list-item', 'table', '-webkit-box'].indexOf(e) > -1}; let a = 0, l = ['ms', 'moz', 'webkit', 'o'], c = e.requestAnimationFrame, u = e.cancelAnimationFrame; for (t = 0; !c && t < l.length; ++t)c = e[`${l[t]}RequestAnimationFrame`], u = e[`${l[t]}CancelAnimationFrame`] || e[`${l[t]}CancelRequestAnimationFrame`]; c || (c = function(t) {let n = (new Date()).getTime(), r = Math.max(0, 16 - (n - a)), i = e.setTimeout(() => {t(n + r)}, r); return a = n + r, i}), u || (u = function(t) {e.clearTimeout(t)}), n.rAF = c.bind(e), n.cAF = u.bind(e); var f = n.type = function(e) {return Object.prototype.toString.call(e).replace(/^\[object (.+)\]$/, '$1').toLowerCase()}; f.String = function(e) {return f(e) === 'string'}, f.Function = function(e) {return f(e) === 'function'}, f.Array = function(e) {return Array.isArray(e)}, f.Number = function(e) {return !f.Array(e) && e - parseFloat(e) + 1 >= 0}, f.DomElement = function(e) {return typeof HTMLElement === 'object' ? e instanceof HTMLElement : e && typeof e === 'object' && e !== null && e.nodeType === 1 && typeof e.nodeName === 'string'}; const d = n.get = {}; return d.elements = function(t) {let n = []; if (f.String(t)) try {t = document.querySelectorAll(t)} catch (r) {return n} if (f(t) === 'nodelist' || f.Array(t)) for (let i = 0, o = n.length = t.length; o > i; i++) {const s = t[i]; n[i] = f.DomElement(s) ? s : d.elements(s)} else (f.DomElement(t) || t === document || t === e) && (n = [t]); return n}, d.scrollTop = function(t) {return t && typeof t.scrollTop === 'number' ? t.scrollTop : e.pageYOffset || 0}, d.scrollLeft = function(t) {return t && typeof t.scrollLeft === 'number' ? t.scrollLeft : e.pageXOffset || 0}, d.width = function(e, t, n) {return o('width', e, t, n)}, d.height = function(e, t, n) {return o('height', e, t, n)}, d.offset = function(e, t) {const n = {top: 0, left: 0}; if (e && e.getBoundingClientRect) {const r = e.getBoundingClientRect(); n.top = r.top, n.left = r.left, t || (n.top += d.scrollTop(), n.left += d.scrollLeft())} return n}, n.addClass = function(e, t) {t && (e.classList ? e.classList.add(t) : e.className += ` ${t}`)}, n.removeClass = function(e, t) {t && (e.classList ? e.classList.remove(t) : e.className = e.className.replace(RegExp(`(^|\\b)${t.split(' ').join('|')}(\\b|$)`, 'gi'), ' '))}, n.css = function(e, t) {if (f.String(t)) return i(e)[s(t)]; if (f.Array(t)) {let n = {}, r = i(e); return t.forEach((e) => {n[e] = r[s(e)]}), n} for (const o in t) {let a = t[o]; a == parseFloat(a) && (a += 'px'), e.style[s(o)] = a}}, n}(window || {})); return e}))
