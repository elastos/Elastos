import Foundation

public class VerifiableCredential: DIDObject {
    private var _types: Array<String>?
    private var _issuer: DID?
    private var _issuanceDate: Date?
    private var _expirationDate: Date?
    private var _subject: VerifiableCredentialSubject?
    private var _proof: VerifiableCredentialProof?
    private var _meta: CredentialMeta?

    private let  RULE_EXPIRE : Int = 1
    private let  RULE_GENUINE: Int = 2
    private let  RULE_VALID  : Int = 3

    private var meta: CredentialMeta?

    init() {}

    init(_ credential: VerifiableCredential) {
        super.init(credential.getId(), credential.getType())

        self._types = credential.getTypes()
        self._issuer = credential.issuer
        self._issuanceDate = credential.issuanceDate
        self._expirationDate = credential.expirationDate
        self._subject = credential.subject
        self._proof = credential.proof
    }

    override func setId(_ id: DIDURL) {
        super.setId(id)
    }

    public override func getType() -> String {
        var builder = ""
        var first = true

        builder.append("[")
        if let _ = self._types {
            for type in self._types! {
                builder.append(!first ? ", ": "")
                builder.append(type)

                if  first {
                    first = true
                }
            }
        }
        builder.append("]")

        return builder
    }

    public func getTypes() -> [String]? {
        // TODO:
        return nil
    }

    func appendType(_ type: String) {
        if  self._types == nil {
            self._types = Array<String>()
        }
        self._types!.append(type)
    }

    func setType(_ newTypes: [String]) {
        if  self._types == nil {
            self._types = Array<String>()
        }
        for type in newTypes {
            self._types!.append(type)
        }
    }

    public var issuer: DID {
        // Guaranteed that this field would not be nil because the object
        // was generated by "builder".
        return self._issuer!
    }

    // This type of getXXXX function would specifically be provided for
    // sdk internal when we can't be sure about it's validity/integrity.
    func getIssuer() -> DID? {
        return self._issuer
    }

    func setIssuer(_ newIssuer: DID) {
        self._issuer = newIssuer
    }

    public var issuanceDate: Date {
        // Guaranteed that this field would not be nil because the object
        // was generated by "builder".
        return self._issuanceDate!
    }

    func getIssuanceDate() -> Date? {
        return self._issuanceDate
    }

    func setIssuanceDate(_ issuanceDate: Date) {
        self._issuanceDate = issuanceDate
    }

    public var expirationDate: Date {
        // Guaranteed that this field would not be nil because the object
        // was generated by "builder".
        return _expirationDate!
    }

    func getExpirationDate() -> Date? {
        return self._issuanceDate
    }

    func setExpirationDate(_ expirationDate: Date) {
        self._expirationDate = expirationDate
    }

    func getMeta() -> CredentialMeta {
        if  self._meta == nil {
            self._meta = CredentialMeta()
        }
        return self._meta!
    }

    func setMeta(_ newValue: CredentialMeta) {
        self._meta = newValue
    }

    public func setExtra(value: String, forName: String) throws {
        guard !forName.isEmpty else {
            throw DIDError.illegalArgument()
        }

        getMeta().setExtra(value, forName)
        if getMeta().hasAttachedStore {
            try getMeta().store?.storeCredentialMeta(self.subject.did, self.getId(), getMeta())
        }
    }

    public func getExtra(forName: String) -> String? {
        return getMeta().getExtra(forName)
    }
    
    public var aliasName: String {
        return getMeta().aliasName
    }

    public func setAliasName(_ newValue: String?) throws {
        getMeta().setAlias(newValue)
        if getMeta().hasAttachedStore {
            try getMeta().store?.storeCredentialMeta(self.subject.did, self.getId(), getMeta())
        }
    }
    
    public func isSelfProclaimed() -> Bool {
        return self.issuer == self.subject.did
    }
    
    private func traceCheck(_ rule: Int) throws -> Bool {
        let controllerDoc = try self.getSubject()?.did.resolve()
        guard let _ = controllerDoc else {
            return false
        }

        switch rule {
        case RULE_EXPIRE:
            if controllerDoc!.isExpired {
                return true
            }
        case RULE_GENUINE:
            if !controllerDoc!.isGenuine {
                return false
            }
        case RULE_VALID:
            if !controllerDoc!.isValid {
                return false
            }
        default:
            // TODO:
            return false
        }

        if !isSelfProclaimed() {
            let issuerDoc = try self.getIssuer()?.resolve()
            guard let _ = issuerDoc else {
                return false
            }

            switch rule {
            case RULE_EXPIRE:
                if issuerDoc!.isExpired {
                    return true
                }
            case RULE_GENUINE:
                if !issuerDoc!.isGenuine {
                    return false
                }
            case RULE_VALID:
                if !issuerDoc!.isValid {
                    return false
                }
            default:
                // TODO:
                return false
            }
        }

        return rule != RULE_EXPIRE
    }
    
    private func checkExpired() throws -> Bool {
        guard let _ = self._expirationDate else {
            return false
        }

        let date = DateHelper.currentDate()   // TODO:
        return DateFormater.comporsDate(self.expirationDate, date)
    }

    public var isExpired: Bool {
        do {
            if try traceCheck(RULE_EXPIRE) {
                return true
            }

            return try checkExpired()
        } catch {
            return false
        }
    }

    private func checkGenuine() throws -> Bool {
        let issuerDoc = try self.issuer.resolve()
        guard let _ = issuerDoc else {
            return false
        }
        // Credential should signed by authentication key.
        guard issuerDoc!.containsAuthenticationKey(forId: self.proof.verificationMethod) else {
            return false
        }
        // Unsupported public key type;
        guard self.proof.type != Constants.DEFAULT_PUBLICKEY_TYPE else {
            return false
        }

        var inputs: [Data] = []
        inputs.append(toJson(true, true).data(using: .utf8)!)

        return try issuerDoc!.verifyEx(self.proof.verificationMethod,
                                       self.proof.signature, inputs)
    }

    public var isGenuine: Bool {
        do {
            if try !traceCheck(RULE_GENUINE) {
                return false
            }

            return try checkGenuine()
        } catch {
            return false
        }
    }

    public var isValid: Bool {
        do {
            if try !traceCheck(RULE_VALID) {
                return false
            }

            return try !checkExpired() && checkGenuine()
        } catch {
            return false
        }
    }

    public var subject: VerifiableCredentialSubject {
        // Guaranteed that this field would not be nil because the object
        // was generated by "builder".
        return self._subject!
    }

    func getSubject() -> VerifiableCredentialSubject? {
        return self._subject
    }

    func setSubject(_ newSubject: VerifiableCredentialSubject) {
        self._subject = newSubject
    }

    public var proof: VerifiableCredentialProof {
        // Guaranteed that this field would not be nil because the object
        // was generated by "builder".
        return self._proof!
    }

    func getProof() -> VerifiableCredentialProof? {
        return self._proof
    }

    func setProof(_ newProof: VerifiableCredentialProof) {
        self._proof = newProof
    }

    private class func fromJson(_ node: Dictionary<String, Any>, _ ref: DID?) throws -> VerifiableCredential {
        let credential = VerifiableCredential()
        let nodeDict = JsonSerializer(node)
        let issuer = try nodeDict.getDID(Constants.ISSUER, JsonSerializer.Options<DID>()
                                    .withOptional()
                                    .withDefValue(ref)
                                    .withHint("credentiall issuer"))

        let issuanceDate = try nodeDict.getDate(Constants.ISSUANCE_DATE,
                                JsonSerializer.Options<Date>()
                                    .withHint("credential expirationDate"))

        let subjectNode = node[Constants.CREDENTIAL_SUBJECT] as? Dictionary<String, Any>
        guard let _ = subjectNode else {
            throw DIDError.malformedCredential("missing credential subject.")
        }
        let subject = try VerifiableCredentialSubject.fromJson(subjectNode!, ref)

        let id = try nodeDict.getDIDURL(Constants.ID, JsonSerializer.Options<DIDURL>()
                                    .withHint("credential id"))

        let proofNode = node[Constants.PROOF] as? Dictionary<String, Any>
        guard let _ = proofNode else {
            throw DIDError.malformedCredential("missing credential proof")
        }
        let proof = try VerifiableCredentialProof.fromJson(proofNode!, ref)

        credential.setIssuer(issuer!)
        credential.setIssuanceDate(issuanceDate)
        credential.setSubject(subject)
        credential.setId(id!)
         credential.setProof(proof)
        if let _ = credential.getIssuer() {
            credential.setIssuer(credential.subject.did)
        }

        return credential
    }

    class func fromJson(_ json: Data) throws -> VerifiableCredential {
        guard !json.isEmpty else {
            throw DIDError.illegalArgument()
        }

        let node: Dictionary<String, Any>
        do {
            node = try JSONSerialization.jsonObject(with: json, options: []) as! Dictionary<String, Any>
        } catch {
            throw DIDError.didResolveError("Parse resolve result error")
        }
        return try fromJson(node, nil)
    }

    class func fromJson(_ json: String) throws -> VerifiableCredential {
        return try fromJson(json.data(using: .utf8)!)
    }

    func toJson(_ generator: JsonGenerator, _ ref: DID?, _ normalized: Bool) {
        toJson(generator, ref, normalized, false)
    }

    func toJson(_ generator: JsonGenerator, _ normalized: Bool) {
        toJson(generator, nil, normalized)
    }

    /*
    * Normalized serialization order:
    *
    * - id
    * - type ordered names array(case insensitive/ascending)
    * - issuer
    * - issuanceDate
    * - expirationDate
    * + credentialSubject
    *   - id
    *   - properties ordered by name(case insensitive/ascending)
    * + proof
    *   - type
    *   - method
    *   - signature
    */
    func toJson(_ generator: JsonGenerator, _ ref: DID?, _ normalized: Bool, _ forSign: Bool) {
        generator.writeStartObject()

        // id
        generator.writeStringField(Constants.ID, IDGetter(getId(), ref).value(normalized))

        // type
        generator.writeFieldName(Constants.TYPE)
        generator.writeStartArray()
        for type in self._types! {
            generator.writeString(type)
        }
        generator.writeEndArray()

        // issuer
        if normalized || self.issuer != self.subject.did {
            generator.writeStringField(Constants.ISSUER, self.issuer.toString())
        }

        // issuanceDate
        generator.writeFieldName(Constants.ISSUANCE_DATE)
        generator.writeString(DateFormatter.convertToUTCStringFromDate(self.issuanceDate))

        // expirationDate
        if let _ = self.getExpirationDate() {
            generator.writeFieldName(Constants.EXPIRATION_DATE)
            generator.writeString(DateFormatter.convertToUTCStringFromDate(self.expirationDate))
        }

        // credenitalSubject
        generator.writeFieldName(Constants.CREDENTIAL_SUBJECT)
        self.subject.toJson(generator, ref, normalized)

        // proof
        if !forSign {
            generator.writeFieldName(Constants.PROOF)
            proof.toJson(generator, issuer, normalized)
        }

        generator.writeEndObject()
    }

    func toJson(_ normalized: Bool, _ forSign: Bool) -> String {
        // TODO:
        return "TODO"
    }
}

extension VerifiableCredential: CustomStringConvertible {
    func toString(_ normalized: Bool) -> String {
        return toJson(normalized, false)
    }

    func toString() -> String {
        return toString(false)
    }

    public var description: String {
        return toString()
    }
}
