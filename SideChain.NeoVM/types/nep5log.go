package types

import (
	"io"
	"math/big"
	"github.com/elastos/Elastos.ELA/common"

	"fmt"
	"github.com/elastos/Elastos.ELA.SideChain.NeoVM/avm"
)

// Nep5Log represents a contract log event. These events are generated by the nep5
// transfer event by the node.
type Nep5Log struct {
	// Consensus fields:
	// address of the contract that generated the event
	Address string

	// nep5 address on transfer about from and to
	From common.Uint160

	To common.Uint160

	Data big.Int

	// Derived fields. These fields are filled in by the node
	// but not secured by consensus.
	// block in which the transaction was included
	BlockNumber uint32 `json:"blockNumber"`
	// hash of the transaction
	TxHash string`json:"transactionHash" gencodec:"required"`
	// index of the transaction in the block
	TxIndex uint32 `json:"transactionIndex" gencodec:"required"`
	// hash of the block in which the transaction was included
	BlockHash string `json:"blockHash"`
	// index of the log in the block
	Index uint32 `json:"logIndex" gencodec:"required"`
}

func (l *Nep5Log) String() string {
	return fmt.Sprint(
		"Address: ", l.Address, "\n\t",
		"From: ", l.From, "\n\t",
		"To: ", l.To, "\n\t",
		"Data:", l.Data.String(),"\n\t",
		"BlockNumber: ", l.BlockNumber, "\n\t",
		"TxHash: ", l.TxHash, "\n\t",
		"TxIndex: ", l.TxIndex, "\n\t",
		"BlockHash: ", l.BlockHash, "\n\t",
		"Index: ", l.Index, "\n\t")
}

func (l *Nep5Log) Serialize(w io.Writer, version byte) error {
	err := common.WriteVarString(w, l.Address)
	if err != nil {
		return err
	}

	err = l.From.Serialize(w)
	if err != nil {
		return err
	}

	err = l.To.Serialize(w)
	if err != nil {
		return err
	}

	err = common.WriteVarBytes(w, l.Data.Bytes())
	if err != nil {
		return err
	}

	err = common.WriteVarString(w, l.TxHash)
	if err != nil {
		return err
	}

	return nil
}

func (l *Nep5Log) Deserialize(r io.Reader, version byte) error {

	addr, err := common.ReadVarString(r)
	if err != nil {
		return err
	}
	l.Address = addr

	l.From = common.Uint160{}
	err = l.From.Deserialize(r)
	if err != nil {
		return err
	}

	l.To = common.Uint160{}
	l.To.Deserialize(r)
	if err != nil {
		return err
	}

	data, err := common.ReadVarBytes(r, avm.MaxItemSize, "Data")
	if err != nil {
		return err
	}
	l.Data = big.Int{}
	l.Data.SetBytes(data)

	txID, err := common.ReadVarString(r)
	if err != nil {
		return err
	}
	l.TxHash = txID

	return nil
}
