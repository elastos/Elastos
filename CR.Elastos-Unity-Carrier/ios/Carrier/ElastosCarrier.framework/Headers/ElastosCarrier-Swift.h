// Generated by Apple Swift version 4.2 effective-3.4 (swiftlang-1000.11.37.1 clang-1000.11.45.1)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import Foundation;
@import ObjectiveC;
#endif

#import <ElastosCarrier/ElastosCarrier.h>

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="ElastosCarrier",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


SWIFT_CLASS_NAMED("BootstrapNode")
@interface ELABootstrapNode : NSObject
/// Ipv4 address.
@property (nonatomic, copy) NSString * _Nullable ipv4;
/// Ipv6 address.
@property (nonatomic, copy) NSString * _Nullable ipv6;
/// Port.
@property (nonatomic, copy) NSString * _Nullable port;
/// public address.
@property (nonatomic, copy) NSString * _Nullable publicKey;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum ELACarrierLogLevel : NSInteger;
@class ELACarrierOptions;
@protocol ELACarrierDelegate;
@class ELACarrierUserInfo;
enum ELACarrierPresenceStatus : NSInteger;
@class ELACarrierFriendInfo;

/// The class representing carrier node.
SWIFT_CLASS_NAMED("Carrier")
@interface ELACarrier : NSObject
/// Carrier node App message max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_APP_MESSAGE_LEN;)
+ (NSInteger)MAX_APP_MESSAGE_LEN SWIFT_WARN_UNUSED_RESULT;
/// Get current carrier node version.
///
/// returns:
/// The current carrier node version.
+ (NSString * _Nonnull)getVersion SWIFT_WARN_UNUSED_RESULT;
/// Check if the carrier address ID is valid.
/// \param address The carrier address to be check
///
///
/// returns:
/// True if carrier address is valid, otherwise false
+ (BOOL)isValidAddress:(NSString * _Nonnull)address SWIFT_WARN_UNUSED_RESULT;
/// Check if the carrier public ID is valid.
/// \param id The carrier id to be check
///
///
/// returns:
/// True if carrier id is valid, otherwise false
+ (BOOL)isValidId:(NSString * _Nonnull)id SWIFT_WARN_UNUSED_RESULT;
/// Extract ID from the carrier node address.
/// \param address The carrier node address.
///
///
/// returns:
/// Valid Id if carrier node address is valid, otherwise nil
+ (NSString * _Nullable)getIdFromAddress:(NSString * _Nonnull)address SWIFT_WARN_UNUSED_RESULT;
/// Set log level for carrier node.
/// Default level to control log output is <code>CarrierLogLevel.Info</code>
/// \param level The log level
///
+ (void)setLogLevel:(enum ELACarrierLogLevel)level;
/// Create node singleton instance. After initialize the instance,
/// itâ€™s ready to start and therefore connect to the carrier network.
/// \param options The options to set for carrier node
///
/// \param delegate The delegate for carrier node to comply with
///
///
/// throws:
/// CarrierError
+ (BOOL)initializeInstanceWithOptions:(ELACarrierOptions * _Nonnull)options delegate:(id <ELACarrierDelegate> _Nonnull)delegate error:(NSError * _Nullable * _Nullable)error;
/// Get a carrier node singleton instance.
///
/// returns:
/// The carrier node instance or ni
+ (ELACarrier * _Nullable)getInstance SWIFT_WARN_UNUSED_RESULT;
/// Start carrier node asynchronously to connect to carrier network.
/// If the connection to network is successful, carrier node starts
/// working.
/// \param iterateInterval Internal loop interval, in milliseconds
///
///
/// throws:
/// CarrierError
- (BOOL)startWithIterateInterval:(NSInteger)iterateInterval error:(NSError * _Nullable * _Nullable)error;
/// Disconnect carrier node from the server, and destroy all associated
/// resources to carrier node instance.
/// After calling the method, the carrier node instance becomes invalid,
/// and can not be refered any more.
- (void)kill;
/// Get node address associated with carrier node instance.
/// Returns: The node address
- (NSString * _Nonnull)getAddress SWIFT_WARN_UNUSED_RESULT;
/// Get node identifier associated with the carrier node instance.
///
/// returns:
/// The node identifier
- (NSString * _Nonnull)r SWIFT_WARN_UNUSED_RESULT;
/// Get user identifier associated with the carrier node instance.
///
/// returns:
/// The user identifier
- (NSString * _Nonnull)getUserId SWIFT_WARN_UNUSED_RESULT;
/// Update the nospam for carrier node address
/// Update the 4-byte nospam part of the Carrier address with host byte order
/// expected. Nospam for Carrier address is used to eliminate spam friend
/// request.
/// \param newNospam The new nospam to address.
///
///
/// throws:
/// CarrierError
- (BOOL)setSelfNospam:(uint32_t)newNospam error:(NSError * _Nullable * _Nullable)error;
/// \param newUserInfo The new user information to set
///
///
/// throws:
/// CarrierError
- (BOOL)setSelfUserInfo:(ELACarrierUserInfo * _Nonnull)newUserInfo error:(NSError * _Nullable * _Nullable)error;
/// Get self user information.
///
/// throws:
/// CarrierError
///
/// returns:
/// The current user information
- (ELACarrierUserInfo * _Nullable)getSelfUserInfo:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Set self presence status
/// \param newPresence The new presence status to friends.
///
///
/// throws:
/// CarrierError
- (BOOL)setSelfPresence:(enum ELACarrierPresenceStatus)newPresence error:(NSError * _Nullable * _Nullable)error;
/// Check if carrier node instance is being ready.
///
/// returns:
/// true if the carrier node instance is ready, or false if not
- (BOOL)isReady SWIFT_WARN_UNUSED_RESULT;
///
/// throws:
/// CarrierError
- (NSArray<ELACarrierFriendInfo *> * _Nullable)getFriends:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Get specified friend information.
/// \param friendId The user identifier of friend
///
///
/// throws:
/// CarrierError
///
/// returns:
/// The friend information to user <code>friendId</code>
- (ELACarrierFriendInfo * _Nullable)getFriendInfoForFriend:(NSString * _Nonnull)friendId error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Set the label of the specified friend.
/// The label of a friend is a private alias name for current user.
/// It can be seen by current user only, and has no impact to the target
/// friend itself.
/// \param friendId the friendâ€™s user identifier
///
/// \param newLabel the new label of specified friend
///
///
/// throws:
/// CarrierError
- (BOOL)setLabelForFriend:(NSString * _Nonnull)friendId withLabel:(NSString * _Nonnull)newLabel error:(NSError * _Nullable * _Nullable)error;
/// Check if the user ID is friend.
/// \param userId The userId to check
///
///
/// returns:
/// True if the user is friend, otherwise false
- (BOOL)isFriendWithUser:(NSString * _Nonnull)userId SWIFT_WARN_UNUSED_RESULT;
/// Attempt to add friend by sending a new friend request.
/// This function will add a new friend with specific address, and then
/// send a friend request to the target node.
/// \param userId The target user id
///
/// \param hello PIN for target user, or any application defined
/// content.
///
///
/// throws:
/// CarrierError
- (BOOL)addFriendWith:(NSString * _Nonnull)userId withGreeting:(NSString * _Nonnull)hello error:(NSError * _Nullable * _Nullable)error;
/// Accept the friend request.
/// This function is used to add a friend in response to a friend request.
/// \param userId The user id who want be friend with current user
///
///
/// throws:
/// CarrierError
- (BOOL)acceptFriendWith:(NSString * _Nonnull)userId error:(NSError * _Nullable * _Nullable)error;
/// Remove friendship with the specified friend.
/// If all correct, Carrier network will clean the friend relationship,
/// and send friend removed message to both.
/// \param friendId The target user id to remove friendship.
///
///
/// throws:
/// CarrierError
- (BOOL)removeFriend:(NSString * _Nonnull)friendId error:(NSError * _Nullable * _Nullable)error;
/// Send a message to the specified friend.
/// The message length may not exceed <code>MAX_APP_MESSAGE_LEN</code>, and message
/// itself should be text-formatted. Larger messages must be splitted by
/// application and sent as separate messages. Other nodes can reassemble
/// the fragments.
/// \param target The target id
///
/// \param msg The message content defined by application
///
///
/// throws:
/// CarrierError
- (BOOL)sendFriendMessageTo:(NSString * _Nonnull)target withMessage:(NSString * _Nonnull)msg error:(NSError * _Nullable * _Nullable)error;
/// Send invite request to the specified friend
/// Application can attach the application defined data with in the invite
/// request, and the data will send to target friend.
/// \param target The target id
///
/// \param data The application defined data send to target user
///
/// \param responseHandler The callback to receive invite reponse
///
///
/// throws:
/// CarrierError
- (BOOL)sendInviteFriendRequestTo:(NSString * _Nonnull)target withData:(NSString * _Nonnull)data error:(NSError * _Nullable * _Nullable)error responseHandler:(void (^ _Nonnull)(ELACarrier * _Nonnull, NSString * _Nonnull, NSInteger, NSString * _Nullable, NSString * _Nullable))responseHandler;
/// Reply the friend invite request.
/// This function will send a invite response to friend.
/// \param target The id(userid@nodeid) who send invite request
///
/// \param status The status code of the response
/// 0 is on success, otherse is error
///
/// \param reason The error message if status is error, or nil if success
///
/// \param data The application defined data send to target user.
/// If the status is error, this will be ignored.
///
///
/// throws:
/// CarrierError
- (BOOL)replyFriendInviteRequestTo:(NSString * _Nonnull)target withStatus:(NSInteger)status reason:(NSString * _Nullable)reason data:(NSString * _Nullable)data error:(NSError * _Nullable * _Nullable)error;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

enum ELACarrierCandidateType : NSInteger;
@class ELACarrierSocketAddress;

SWIFT_CLASS_NAMED("CarrierAddressInfo")
@interface ELACarrierAddressInfo : NSObject
@property (nonatomic, readonly) enum ELACarrierCandidateType candidateType;
@property (nonatomic, readonly, strong) ELACarrierSocketAddress * _Nonnull address;
@property (nonatomic, readonly, strong) ELACarrierSocketAddress * _Nullable relatedAddress;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM_NAMED(NSInteger, ELACarrierCandidateType, "CandidateType", closed) {
  ELACarrierCandidateTypeHost = 0,
  ELACarrierCandidateTypeServerReflexive = 1,
  ELACarrierCandidateTypePeerReflexive = 2,
  ELACarrierCandidateTypeRelayed = 3,
};


SWIFT_CLASS_NAMED("SocketAddress")
@interface ELACarrierSocketAddress : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull hostname;
@property (nonatomic, readonly) NSInteger port;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

/// Carrier node connection status to carrier network.
typedef SWIFT_ENUM_NAMED(NSInteger, ELACarrierConnectionStatus, "CarrierConnectionStatus", closed) {
/// Carrier node connected to the network.
/// Indicate the node is online.
  ELACarrierConnectionStatusConnected = 0,
/// There is no connection to the network.
/// Indicate the node is offline.
  ELACarrierConnectionStatusDisconnected = 1,
};


/// The protocol to Carrier node instance.
SWIFT_PROTOCOL_NAMED("CarrierDelegate")
@protocol ELACarrierDelegate
@optional
/// Tell the delegate that Carrier node will become idle for a while,
/// during which application can perform instant idle work.
/// \param carrier Carrier node instance
///
///
/// returns:
/// Void
- (void)carrierWillBecomeIdle:(ELACarrier * _Nonnull)carrier;
/// Tell the delegate that the self connection status changed.
/// \param carrier Carrier node instance
///
/// \param newStatus Current connection status.
/// see <code>CarrierConnectionStatus</code>
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier connectionStatusDidChange:(enum ELACarrierConnectionStatus)newStatus;
@required
/// Tell the delegate that Carrier node is being ready.
/// Application should wait this callback invoked before calling any
/// carrier function to interact with friends.
/// \param carrier Carrier node instance
///
///
/// returns:
/// Void
- (void)carrierDidBecomeReady:(ELACarrier * _Nonnull)carrier;
@optional
/// Tell the delegate that current self user info has been changed.
/// \param carrier Carrier node instance
///
/// \param newInfo The newly updated user information
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier selfUserInfoDidChange:(ELACarrierUserInfo * _Nonnull)newInfo;
/// Tell the delegate to iterate each friend item in friend list.
/// \param carrier Carrier node instance
///
/// \param friends The friends list.
///
- (void)carrier:(ELACarrier * _Nonnull)carrier didReceiveFriendsList:(NSArray<ELACarrierFriendInfo *> * _Nonnull)friends;
/// Tell the delegate that friend connection status has been changed.
/// \param carrier Carrier node instance
///
/// \param friendId The friendâ€™s user idza z z
///
/// \param newStatus The update
///
/// \param newInfo The updated friend information
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier friendConnectionDidChange:(NSString * _Nonnull)friendId newStatus:(enum ELACarrierConnectionStatus)newStatus;
/// Tell the delegate that friend information has been changed.
/// \param carrier Carrier node instance
///
/// \param friendId The friendâ€™s user id
///
/// \param newInfo The updated friend information
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier friendInfoDidChange:(NSString * _Nonnull)friendId newInfo:(ELACarrierFriendInfo * _Nonnull)newInfo;
/// Tell the delegate that friend presence has been changed.
/// \param carrier Carrier node instance
///
/// \param friendId The friendâ€™s user id
///
/// \param newPresence The updated presence status of the friend
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier friendPresenceDidChange:(NSString * _Nonnull)friendId newPresence:(enum ELACarrierPresenceStatus)newPresence;
/// Tell the delegate that an friend request message has been received.
/// \param carrier Carrier node instance
///
/// \param userId The user id who want be friend with current user
///
/// \param userInfo The user information to <code>userId</code>
///
/// \param hello The PIN for target user, or any application defined
/// content
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier didReceiveFriendRequestFromUser:(NSString * _Nonnull)userId withUserInfo:(ELACarrierUserInfo * _Nonnull)userInfo hello:(NSString * _Nonnull)hello;
/// Tell the delegate that an new friend has been added to current
/// userâ€™s friend list.
/// \param carrier Carrier node instance
///
/// \param newFriend The added friendâ€™s information
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier newFriendAdded:(ELACarrierFriendInfo * _Nonnull)newFriend;
/// Tell the delegate that an friend has been removed from current userâ€™s
/// friend list.
/// \param carrier Carrier node instance
///
/// \param friendId The friendâ€™s user id
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier friendRemoved:(NSString * _Nonnull)friendId;
/// Tell the delegate that an friend message has been received.
/// \param carrier Carrier node instance
///
/// \param from The id(userid@nodeid) from who send the message
///
/// \param message The message content
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier didReceiveFriendMessage:(NSString * _Nonnull)from withMessage:(NSString * _Nonnull)message;
/// Tell the delegate that an friend invite request has been received.
/// \param carrier Carrier node instance
///
/// \param from The user id from who send the invite request
///
/// \param data The application defined data sent from friend
///
///
/// returns:
/// Void
- (void)carrier:(ELACarrier * _Nonnull)carrier didReceiveFriendInviteRequest:(NSString * _Nonnull)from withData:(NSString * _Nonnull)data;
@end


/// A class representing the Carrier user information.
/// In Elastos carrier SDK, self and all friends are carrier user, and have
/// same user attributes.
SWIFT_CLASS_NAMED("CarrierUserInfo")
@interface ELACarrierUserInfo : NSObject
/// Elastos carrier User ID max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_ID_LEN;)
+ (NSInteger)MAX_ID_LEN SWIFT_WARN_UNUSED_RESULT;
/// Elastos carrier user name max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_USER_NAME_LEN;)
+ (NSInteger)MAX_USER_NAME_LEN SWIFT_WARN_UNUSED_RESULT;
/// Elastos carrier user description max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_USER_DESCRIPTION_LEN;)
+ (NSInteger)MAX_USER_DESCRIPTION_LEN SWIFT_WARN_UNUSED_RESULT;
/// Elastos carrier user gender max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_GENDER_LEN;)
+ (NSInteger)MAX_GENDER_LEN SWIFT_WARN_UNUSED_RESULT;
/// Elastos carrier user phone number max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_PHONE_LEN;)
+ (NSInteger)MAX_PHONE_LEN SWIFT_WARN_UNUSED_RESULT;
/// Elastos carrier user email address max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_EMAIL_LEN;)
+ (NSInteger)MAX_EMAIL_LEN SWIFT_WARN_UNUSED_RESULT;
/// Elastos carrier user region max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_REGION_LEN;)
+ (NSInteger)MAX_REGION_LEN SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
/// User ID.
@property (nonatomic, readonly, copy) NSString * _Nullable userId;
/// Nickname, also as display name.
@property (nonatomic, copy) NSString * _Nullable name;
/// Userâ€™s brief description, also as whatâ€™s up.
@property (nonatomic, copy) NSString * _Nullable briefDescription;
/// If user has avatar.
@property (nonatomic) BOOL hasAvatar;
/// Userâ€™s gender.
@property (nonatomic, copy) NSString * _Nullable gender;
/// Userâ€™s phone number.
@property (nonatomic, copy) NSString * _Nullable phone;
/// Userâ€™s email address.
@property (nonatomic, copy) NSString * _Nullable email;
/// Userâ€™s region information.
@property (nonatomic, copy) NSString * _Nullable region;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// A class representing the carrier friend information.
/// Include the basic user information and the extra friend information.
SWIFT_CLASS_NAMED("CarrierFriendInfo")
@interface ELACarrierFriendInfo : ELACarrierUserInfo
/// carrier friend label max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_LABEL_LEN;)
+ (NSInteger)MAX_LABEL_LEN SWIFT_WARN_UNUSED_RESULT;
/// carrier node presence max length.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_USER_PRESENCE_LEN;)
+ (NSInteger)MAX_USER_PRESENCE_LEN SWIFT_WARN_UNUSED_RESULT;
/// Friendâ€™s presence status.
@property (nonatomic) enum ELACarrierConnectionStatus status;
/// Label name for the friend.
@property (nonatomic, copy) NSString * _Nullable label;
/// Friendâ€™s presence status.
@property (nonatomic) enum ELACarrierPresenceStatus presence;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

/// Carrier log level to control or filter log output
typedef SWIFT_ENUM_NAMED(NSInteger, ELACarrierLogLevel, "CarrierLogLevel", closed) {
/// Log level None
/// Indicate disable log output.
  ELACarrierLogLevelNone = 0,
/// Log level fatal
/// Indicate output log with level â€˜Fatalâ€™ only.
  ELACarrierLogLevelFatal = 1,
/// Log level error.
/// Indicate output log above â€˜Errorâ€™ level.
  ELACarrierLogLevelError = 2,
/// Log level warning.
/// Indicate output log above â€˜Warningâ€™ level.
  ELACarrierLogLevelWarning = 3,
/// Log level info.
/// Indicate output log above â€˜Infoâ€™ level.
  ELACarrierLogLevelInfo = 4,
/// Log level debug.
/// Indicate output log above â€˜Debugâ€™ level.
  ELACarrierLogLevelDebug = 5,
/// Log level trace.
/// Indicate output log above â€˜Traceâ€™ level.
  ELACarrierLogLevelTrace = 6,
/// Log level verbose.
/// Indicate output log above â€˜Verboseâ€™ level.
  ELACarrierLogLevelVerbose = 7,
};

typedef SWIFT_ENUM_NAMED(NSInteger, ELACarrierNetworkTopology, "CarrierNetworkTopology", closed) {
  ELACarrierNetworkTopologyLAN = 0,
  ELACarrierNetworkTopologyP2P = 1,
  ELACarrierNetworkTopologyRelayed = 2,
};


/// CarrierOptions defines several settings that control the way the carrier
/// node connects to others.
SWIFT_CLASS_NAMED("CarrierOptions")
@interface ELACarrierOptions : NSObject
/// The application defined persistent data location.
/// The location must be set.
@property (nonatomic, copy) NSString * _Nullable persistentLocation;
/// The option to decide to use udp transport or not. Setting this option
/// to false will force Carrier node to use TCP only, which will
/// potentially slow down the message to run through.
@property (nonatomic) BOOL udpEnabled;
@property (nonatomic, copy) NSArray<ELABootstrapNode *> * _Nullable bootstrapNodes;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Carrier node presence status to friends
typedef SWIFT_ENUM_NAMED(NSInteger, ELACarrierPresenceStatus, "CarrierPresenceStatus", closed) {
/// Carrier node in online or available to friends.
  ELACarrierPresenceStatusNone = 0,
/// Carrier node is being away.
  ELACarrierPresenceStatusAway = 1,
/// Carrier node is being busy.
  ELACarrierPresenceStatusBusy = 2,
};

enum ELACarrierStreamType : NSInteger;
@protocol ELACarrierStreamDelegate;
@class ELACarrierStream;
enum ELAPortForwardingProtocol : NSInteger;

/// The class representing the carrier session conversation.
SWIFT_CLASS_NAMED("CarrierSession")
@interface ELACarrierSession : NSObject
/// Close a session to friend. All resources include streams, channels,
/// portforwardings associated with current session will be destroyed.
- (void)close;
/// Get remote peer id.
///
/// returns:
/// The remote peer userid or userid@nodeid
- (NSString * _Nonnull)getPeer SWIFT_WARN_UNUSED_RESULT;
/// TODO: Add setUserdata & getUserdata
/// Send session request to the friend.
/// \param handler A handler to receive the session response
///
///
/// throws:
/// CarrierError
- (BOOL)sendInviteRequestWithResponseHandler:(void (^ _Nonnull)(ELACarrierSession * _Nonnull, NSInteger, NSString * _Nullable, NSString * _Nullable))handler error:(NSError * _Nullable * _Nullable)error;
/// Reply the session request from friend.
/// This function will send a session response to friend.
/// \param status The status code of the response. 0 is success,
/// otherwise is error
///
/// \param reason The error message if status is error, or nil if success
///
///
/// throws:
/// CarrierError
- (BOOL)replyInviteRequestWithStatus:(NSInteger)status reason:(NSString * _Nullable)reason error:(NSError * _Nullable * _Nullable)error;
/// Begin to start a session.
/// All streams in current session will try to connect with remote friend,
/// The stream status will update to application by streamâ€™s
/// <code>CarrierStreamDelegate</code>.
/// \param sdp The remote userâ€™s SDP.
/// Reference: https://tools.ietf.org/html/rfc4566
///
///
/// throws:
/// CarrierError
- (BOOL)startWithRemoteSdp:(NSString * _Nonnull)sdp error:(NSError * _Nullable * _Nullable)error;
/// Add a new stream to session.
/// Carrier stream supports several underlying transport mechanisms:
/// <ul>
///   <li>
///     Plain/encrypted UDP data gram protocol
///   </li>
///   <li>
///     Plain/encrypted TCP like reliable stream protocol
///   </li>
///   <li>
///     Multiplexing over UDP
///   </li>
///   <li>
///     Multiplexing over TCP like reliable protocol
///   </li>
/// </ul>
/// Application can use options to specify the new stream mode.
/// Multiplexing over UDP can not provide reliable transport.
/// \param type The stream type defined in CarrierStreamType
///
/// \param options The stream mode options
///
/// \param delegate The Application defined protocol defined in
/// <code>CarrierStreamDelegate</code>
///
///
/// throws:
/// CarrierError
///
/// returns:
/// The new added carrier stream
- (ELACarrierStream * _Nullable)addStreamWithType:(enum ELACarrierStreamType)type options:(ELACarrierStreamOptions)options delegate:(id <ELACarrierStreamDelegate> _Nonnull)delegate error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Remove a stream from session
/// \param stream The carrier stream to be removed
///
///
/// throws:
/// CarrierError
- (BOOL)removeStream:(ELACarrierStream * _Nonnull)stream error:(NSError * _Nullable * _Nullable)error;
/// Add a new portforwarding service to session.
/// The registered services can be used by remote peer in portforwarding
/// request.
/// \param serviceName The new service name, should be unique in session scope
///
/// \param proto The protocol of the service
///
/// \param host The host name or ip of the service
///
/// \param port The port of the service
///
///
/// throws:
/// CarrierError
- (BOOL)addServiceWithName:(NSString * _Nonnull)serviceName protocol:(enum ELAPortForwardingProtocol)proto host:(NSString * _Nonnull)host port:(NSString * _Nonnull)port error:(NSError * _Nullable * _Nullable)error;
/// Remove a portforwarding server to session.
/// This function has not effect on existing portforwarings.
/// \param serviceName The service name
///
- (void)removeServiceWithName:(NSString * _Nonnull)serviceName;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// The class representing carrier session manager.
SWIFT_CLASS_NAMED("CarrierSessionManager")
@interface ELACarrierSessionManager : NSObject
/// Get a carrier session manager instance.
/// This function is convinience way to get instance without interest to
/// session request from friends.
/// \param carrier Carrier node instance
///
/// \param options The options to set for carrier session manager
///
///
/// throws:
/// CarrierError
///
/// returns:
/// A carrier session manager
+ (ELACarrierSessionManager * _Nullable)getInstance:(ELACarrier * _Nonnull)carrier error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Get a carrier session manager instance.
/// \param carrier Carrier node instance
///
/// \param options The options to set for carrier session manager.
///
/// \param handler The handler for carrier session manager to process session
/// request from friends.
///
///
/// throws:
/// CarrierError
///
/// returns:
/// A carrier session manager
+ (ELACarrierSessionManager * _Nullable)getInstance:(ELACarrier * _Nonnull)carrier usingHandler:(void (^ _Nonnull)(ELACarrier * _Nonnull, NSString * _Nonnull, NSString * _Nonnull))handler error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Get a carrier session manager instance.
///
/// returns:
/// The carrier session manager or nil
+ (ELACarrierSessionManager * _Nullable)getInstance SWIFT_WARN_UNUSED_RESULT;
/// Clean up carrier session manager.
- (void)cleanup;
/// Create a new session converstation to the specified friend.
/// The session object represent a conversation handle to a friend.
/// \param target The target id.
///
///
/// throws:
/// CarrierError
///
/// returns:
/// The new CarrierSession
- (ELACarrierSession * _Nullable)newSessionTo:(NSString * _Nonnull)target error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class ELACarrierTransportInfo;
@class NSNumber;

/// The class representing carrier stream.
SWIFT_CLASS_NAMED("CarrierStream")
@interface ELACarrierStream : NSObject
/// Get the carrier stream type.
///
/// returns:
/// The stream type defined in CarrierStreamType
- (enum ELACarrierStreamType)getType SWIFT_WARN_UNUSED_RESULT;
/// TODO: add getState
- (ELACarrierTransportInfo * _Nullable)getTransportInfoAndReturnError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Send outgoing data to remote peer.
/// If the stream is in multiplexing mode, application can not call this
/// function to send data. If this function is called on multiplexing mode
/// stream, it will throw Error.
/// \param data The ougoing data
///
///
/// throws:
/// CarrierError
///
/// returns:
/// Bytes of data sent on success
- (NSNumber * _Nullable)writeData:(NSData * _Nonnull)data error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Open a new channel on multiplexing stream.
/// If the stream is not multiplexing this function will throw Error.
/// \param cookie The application defined data passed to remote peer.
///
///
/// throws:
/// CarrierError
///
/// returns:
/// New channel ID
- (NSNumber * _Nullable)openChannelWithCookie:(NSString * _Nonnull)cookie error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Close a new channel on multiplexing stream.
/// If the stream is not multiplexing this function will throw Error.
/// <ul>
///   <li>
///     Parameter:
///     <ul>
///       <li>
///         channel: The channel ID to close
///       </li>
///     </ul>
///   </li>
/// </ul>
///
/// throws:
/// CarrierError
- (BOOL)closeChannel:(NSInteger)channel error:(NSError * _Nullable * _Nullable)error;
/// Send outgoing data to remote peer.
/// If the stream is not multiplexing this function will throw Error.
/// \param channel The channel ID
///
/// \param data The outgoing data
///
///
/// throws:
/// CarrierError
///
/// returns:
/// Bytes of data sent on sucess
- (NSNumber * _Nullable)writeChannel:(NSInteger)channel data:(NSData * _Nonnull)data error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Request remote peer to pend channel data sending.
/// If the stream is not multiplexing this function will throw Error.
/// \param channel The channel ID
///
///
/// throws:
/// CarrierError
- (BOOL)pendChannel:(NSInteger)channel error:(NSError * _Nullable * _Nullable)error;
/// Request remote peer to resume channel data sending.
/// If the stream is not multiplexing this function will throw Error.
/// \param channel The channel ID
///
///
/// throws:
/// CarrierError
- (BOOL)resumeChannel:(NSInteger)channel error:(NSError * _Nullable * _Nullable)error;
/// Open a port forwarding to remote service over multiplexing.
/// If the stream is not multiplexing this function will throw Error.
/// \param service The remote service name
///
/// \param proto Port forwarding protocol
///
/// \param host Local host or ip to bind. Defaultlly port forwarding
/// will bind to localhost
///
/// \param port Local port to bind
///
///
/// throws:
/// CarrierError
///
/// returns:
/// Port forwarding ID
- (NSNumber * _Nullable)openPortForwardingForService:(NSString * _Nonnull)service withProtocol:(enum ELAPortForwardingProtocol)proto host:(NSString * _Nonnull)host port:(NSString * _Nonnull)port error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Close a port forwarding.
/// If the stream is not multiplexing this function will throw Error.
/// \param portForwarding The port forwarding ID
///
///
/// throws:
/// CarrierError
- (BOOL)closePortForwarding:(NSInteger)portForwarding error:(NSError * _Nullable * _Nullable)error;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

enum ELACarrierStreamState : NSInteger;
enum ELACloseReason : NSInteger;

/// The protocol to carrier stream instance.
/// Include stream status callback, stream data callback, and channel
/// callbacks.
SWIFT_PROTOCOL_NAMED("CarrierStreamDelegate")
@protocol ELACarrierStreamDelegate
@optional
/// Tell the delegate that the state of carrier stream has been changed.
/// \param stream The carrier stream instance
///
/// \param newState Stream state defined in <code>CarrierStreamState</code>
///
- (void)carrierStream:(ELACarrierStream * _Nonnull)stream stateDidChange:(enum ELACarrierStreamState)newState;
/// Tell the delegate that the current stream received an incomping
/// packet.
/// If the stream enabled multiplexing mode, application will not
/// receive stream-layered data callback any more. All data will
/// reported as multiplexing channel data.
/// \param stream The carrier stream instance
///
/// \param data The received packet data
///
- (void)carrierStream:(ELACarrierStream * _Nonnull)stream didReceiveData:(NSData * _Nonnull)data;
/// Tell the delegate that an new request within sesion to open multiplexing
/// channel has been received.
/// \param stream The carrier stream instance
///
/// \param wantChannel The channel ID
///
/// \param cookie Application defined string data send from remote peer.
///
///
/// returns:
/// True on success, or false if an error occurred.
/// The channel will continue to open only this callback return true,
/// otherwise the channel will be closed.
- (BOOL)carrierStream:(ELACarrierStream * _Nonnull)stream shouldOpenNewChannel:(NSInteger)wantChannel withCookie:(NSString * _Nonnull)cookie SWIFT_WARN_UNUSED_RESULT;
/// Tell the delegate that new multiplexing channel has been opened.
/// \param stream The carrier stream instance
///
/// \param newChannel The channel ID
///
- (void)carrierStream:(ELACarrierStream * _Nonnull)stream didOpenNewChannel:(NSInteger)newChannel;
/// Tell the delegate that an multiplexing channel has been closed.
/// \param stream The carrier stream instance
///
/// \param channel The channel ID
///
/// \param reason Channel close reason code, defined in <code>CloseReason</code>.
///
- (void)carrierStream:(ELACarrierStream * _Nonnull)stream didCloseChannel:(NSInteger)channel withReason:(enum ELACloseReason)reason;
/// Tell the delegate that the channel received an incoming packet.
/// \param stream The carrier stream instance
///
/// \param channel The channel ID
///
/// \param data The received data
///
///
/// returns:
/// True on success, or false if an error occurred.
/// If this callback return false, the channel will be closed
/// with CloseReason_Error.
- (BOOL)carrierStream:(ELACarrierStream * _Nonnull)stream didReceiveDataFromChannel:(NSInteger)channel withData:(NSData * _Nonnull)data SWIFT_WARN_UNUSED_RESULT;
/// Tell the delegate that the channel should pend data sending to remote
/// peer.
/// \param stream The carrier stream instance
///
/// \param channel The channel ID
///
- (void)carrierStream:(ELACarrierStream * _Nonnull)stream channelPending:(NSInteger)channel;
/// Tell the delegate that the channel should resume data pending to remote
/// peer.
/// \param stream The carrier stream instance
///
/// \param channel The channel ID
///
- (void)carrierStream:(ELACarrierStream * _Nonnull)stream channelResumed:(NSInteger)channel;
@end

/// Elastos carrier stream state.
/// The stream state will be changed according to the phase of the stream.
typedef SWIFT_ENUM_NAMED(NSInteger, ELACarrierStreamState, "CarrierStreamState", closed) {
/// Initialized stream.
  ELACarrierStreamStateInitialized = 1,
/// The underlying transport is ready for the stream.
  ELACarrierStreamStateTransportReady = 2,
/// The stream is trying to connect the remote.
  ELACarrierStreamStateConnecting = 3,
/// The stream connected with remove peer.
  ELACarrierStreamStateConnected = 4,
/// The stream is deactivated.
  ELACarrierStreamStateDeactivated = 5,
/// The stream closed normally.
  ELACarrierStreamStateClosed = 6,
/// The stream is on error, cannot to continue.
  ELACarrierStreamStateError = 7,
};

/// Elastos carrier stream type.
/// Reference:
/// https://tools.ietf.org/html/rfc4566#section-5.14
/// https://tools.ietf.org/html/rfc4566#section-8
typedef SWIFT_ENUM_NAMED(NSInteger, ELACarrierStreamType, "CarrierStreamType", closed) {
/// Audio stream
  ELACarrierStreamTypeAudio = 0,
/// Video stream
  ELACarrierStreamTypeVideo = 1,
/// Text stream
  ELACarrierStreamTypeText = 2,
/// Application stream
  ELACarrierStreamTypeApplication = 3,
/// Message stream
  ELACarrierStreamTypeMessage = 4,
};


SWIFT_CLASS_NAMED("CarrierTransportInfo")
@interface ELACarrierTransportInfo : NSObject
@property (nonatomic, readonly) enum ELACarrierNetworkTopology networkTopology;
@property (nonatomic, readonly, strong) ELACarrierAddressInfo * _Nonnull localAddressInfo;
@property (nonatomic, readonly, strong) ELACarrierAddressInfo * _Nonnull remoteAddressInfo;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// Multiplexing channel close reason mode.
typedef SWIFT_ENUM_NAMED(NSInteger, ELACloseReason, "CloseReason", closed) {
/// Channel closed normally.
  ELACloseReasonNormal = 0,
/// Channel closed because timeout.
  ELACloseReasonTimeout = 1,
/// Channel closed because error occured.
  ELACloseReasonError = 2,
};

/// Port forwarding supported protocols.
typedef SWIFT_ENUM_NAMED(NSInteger, ELAPortForwardingProtocol, "PortForwardingProtocol", closed) {
/// TCP protocol.
  ELAPortForwardingProtocolTCP = 1,
};

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
